/**
 * generated by Xtext
 */
package edu.cmu.sei.alisa.validation;

import com.google.common.base.Objects;
import edu.cmu.sei.alisa.alisa.Goal;
import edu.cmu.sei.alisa.alisa.Organization;
import edu.cmu.sei.alisa.alisa.Requirement;
import edu.cmu.sei.alisa.alisa.Stakeholder;
import edu.cmu.sei.alisa.alisa.VerificationActivity;
import edu.cmu.sei.alisa.validation.AbstractAlisaValidator;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.osate.aadl2.Aadl2Package;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class AlisaValidator extends AbstractAlisaValidator {
  public final static String INVALID_IDENTIFIER = "existingIdentifier";
  
  @Check
  public void checkStakeholder(final Stakeholder stakeholder) {
    this.checkStakeholderName(stakeholder);
  }
  
  public void checkStakeholderName(final Stakeholder stakeholder) {
    EObject _eContainer = stakeholder.eContainer();
    Organization org = ((Organization) _eContainer);
    boolean _notEquals = (!Objects.equal(org, null));
    if (_notEquals) {
      EList<Stakeholder> _stakeholder = org.getStakeholder();
      for (final Stakeholder other : _stakeholder) {
        if ((other instanceof Stakeholder)) {
          Stakeholder otherStak = ((Stakeholder) other);
          boolean _notEquals_1 = (!Objects.equal(otherStak, null));
          if (_notEquals_1) {
            boolean _and = false;
            boolean _notEquals_2 = (!Objects.equal(otherStak, stakeholder));
            if (!_notEquals_2) {
              _and = false;
            } else {
              String _name = otherStak.getName();
              String _name_1 = stakeholder.getName();
              boolean _equalsIgnoreCase = _name.equalsIgnoreCase(_name_1);
              _and = _equalsIgnoreCase;
            }
            if (_and) {
              EAttribute _namedElement_Name = Aadl2Package.eINSTANCE.getNamedElement_Name();
              this.error("Stakeholders names have to be unique", _namedElement_Name);
              return;
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkVerificationActivity(final VerificationActivity verificationActivity) {
    this.checkVerificationActivityName(verificationActivity);
  }
  
  public void checkVerificationActivityName(final VerificationActivity verificationActivity) {
    throw new Error("Unresolved compilation problems:"
      + "\nVerificationLibrary cannot be resolved to a type."
      + "\nVerificationLibrary cannot be resolved to a type."
      + "\n!= cannot be resolved"
      + "\ncontent cannot be resolved");
  }
  
  @Check
  public void checkRequirement(final Requirement requirement) {
    this.checkRequirementName(requirement);
  }
  
  public void checkRequirementName(final Requirement requirement) {
    throw new Error("Unresolved compilation problems:"
      + "\nRequirements cannot be resolved to a type."
      + "\n!= cannot be resolved"
      + "\nreqs cannot be resolved");
  }
  
  @Check
  public void checkGoal(final Goal requirement) {
    this.checkGoalName(requirement);
  }
  
  public void checkGoalName(final Goal requirement) {
    throw new Error("Unresolved compilation problems:"
      + "\nGoals cannot be resolved to a type."
      + "\nGoals cannot be resolved to a type."
      + "\nRequirementDocument cannot be resolved to a type."
      + "\nRequirementDocument cannot be resolved to a type."
      + "\n!= cannot be resolved"
      + "\ngoals cannot be resolved"
      + "\n!= cannot be resolved"
      + "\ncontent cannot be resolved");
  }
}
